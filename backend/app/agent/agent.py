from typing import Dict, List, Any
import os
import json

from langgraph.graph import StateGraph, END
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.prompts import ChatPromptTemplate

from app.agent.tools import (
    generate_explanations_for_topic,
    search_youtube_videos,
    generate_mermaid_for_topic,
)

# -------------------------------------------------------------------
# HARD REQUIREMENTS (AI-ONLY MODE)
# -------------------------------------------------------------------

if not os.getenv("GOOGLE_API_KEY"):
    raise RuntimeError("GOOGLE_API_KEY is required to run the course generation agent.")

llm = ChatGoogleGenerativeAI(
    model="gemini-2.5-flash",
    temperature=0.3
)

# -------------------------------------------------------------------
# STATE
# -------------------------------------------------------------------

class CourseState(dict):
    prompt: str
    enhanced_prompt: str
    topics: List[str]
    course: Dict[str, Any]

# -------------------------------------------------------------------
# NODE 1: Enhance Prompt → Course Title
# -------------------------------------------------------------------

def node_enhance_prompt(state: CourseState) -> CourseState:
    prompt = ChatPromptTemplate.from_messages([
        ("system", "You are a senior instructional designer."),
        ("human", "Generate a concise professional course title (max 12 words) for: {prompt}")
    ])

    chain = prompt | llm
    resp = chain.invoke({"prompt": state["prompt"]})

    state["enhanced_prompt"] = resp.content.strip()
    return state

# -------------------------------------------------------------------
# NODE 2: Generate Course Topics (Modules)
# -------------------------------------------------------------------

def node_generate_topics(state: CourseState) -> CourseState:
    prompt = ChatPromptTemplate.from_messages([
        ("system", "You are an expert curriculum architect. Return JSON only."),
        ("human", """
        Design a complete course for "{title}".

        Requirements:
        - 8–12 modules
        - Progressive difficulty
        - Industry-relevant
        - Each module should be clearly distinct
        - Return ONLY a JSON array of strings
        """)
    ])

    chain = prompt | llm
    resp = chain.invoke({"title": state["enhanced_prompt"]})

    topics = json.loads(resp.content)

    if not isinstance(topics, list) or not topics:
        raise ValueError("Invalid topics generated by AI")

    state["topics"] = topics
    return state

# -------------------------------------------------------------------
# HELPER: Generate Submodules per Topic
# -------------------------------------------------------------------

def generate_subtopics(topic: str) -> List[str]:
    prompt = ChatPromptTemplate.from_messages([
        ("system", "You are a subject matter expert. Return JSON only."),
        ("human", """
        For the course module "{topic}", generate 4–6 detailed submodules.
        Each submodule should represent a clear learning unit.
        Return ONLY a JSON array of short strings.
        """)
    ])

    chain = prompt | llm
    resp = chain.invoke({"topic": topic})

    subtopics = json.loads(resp.content)

    if not isinstance(subtopics, list) or not subtopics:
        raise ValueError(f"Invalid subtopics for module: {topic}")

    return subtopics

# -------------------------------------------------------------------
# NODE 3: Generate Full Course Content
# -------------------------------------------------------------------

def node_generate_course(state: CourseState) -> CourseState:
    modules: Dict[str, Any] = {}

    for topic in state["topics"]:
        subtopics = generate_subtopics(topic)

        explanations = generate_explanations_for_topic(topic, subtopics)
        videos = search_youtube_videos(f"{topic} tutorial", limit=3)
        mermaid = generate_mermaid_for_topic(topic, list(explanations.keys()))

        modules[topic] = {
            "module_title": topic,
            "submodules": [
                {
                    "title": sub,
                    "explanation": explanations.get(sub, "")
                }
                for sub in subtopics
            ],
            "recommended_videos": videos,
            "concept_map": mermaid
        }

    state["course"] = {
        "title": state["enhanced_prompt"],
        "modules": modules
    }

    return state

# -------------------------------------------------------------------
# GRAPH BUILDER
# -------------------------------------------------------------------

def build_graph():
    graph = StateGraph(CourseState)

    graph.add_node("enhance_prompt", node_enhance_prompt)
    graph.add_node("generate_topics", node_generate_topics)
    graph.add_node("generate_course", node_generate_course)

    graph.set_entry_point("enhance_prompt")
    graph.add_edge("enhance_prompt", "generate_topics")
    graph.add_edge("generate_topics", "generate_course")
    graph.add_edge("generate_course", END)

    return graph.compile()

# -------------------------------------------------------------------
# PUBLIC API
# -------------------------------------------------------------------

def run_workflow(user_prompt: str) -> Dict[str, Any]:
    workflow = build_graph()
    final_state = workflow.invoke({"prompt": user_prompt})
    return final_state["course"]
